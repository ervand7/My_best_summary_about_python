Инструкция по установке гит на мак
https://netology.ru/profile/program/git-18/lessons/42367/lesson_items/193283

Фишки и возможности гит https://netology-code.github.io/guides/git-links/

```````````````````````````````````````````````
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
lesson_1: Version control system implementation

Первоначальная настройка
Настройка информации о пользователе для всех локальных репозиториев

$ git config --global user.name "имя"
Устанавливает имя, которое будет отображаться в поле автора у выполняемых вами коммитов

$ git config --global user.email "адрес электронной почты"
Устанавливает адрес электронной почты, который будет отображаться в информации о выполняемых вами коммитах

$ git config --global user.name
$ git config --global user.email
Проверить настройку учетной записи

git config --global core.editor nano
Устанавливаем дружелюбный редактор файлов, который у нас затем будет по умолчанию. Но лучше этим редактором никогда не пользоваться.

```````````````````````````````````````````````

Работа в локальном репо

$ git init
Инициализация репо. Скрытую папку можно посмотреть нажав command-shift-точка
Если вдруг случайно проинициализировал рабочий стол, то команда    rm -rf ~/.git    все исправит и вернет в исходное состояние

$ git add 
добавление
$ git add --all
добавить все
$ git add *
также добавить все
$ git add *py
добавить все файлы с расширением 'py'

$ git diff
смотрим непроиндексированные изменения
$ git diff --cached
смотрим проиндексированные изменения

$ git status
просмотр статуса изменений

$ git commit
Если так попробовать фиксировать изменения, о мы попадем в неудобный редактор.

$ git commit -a -m "My_commit"
Хороший вариант для фиксации изменений
Флаг -a(--all) говорит о том, что мы добавляем в stage все удалённые/изменённые файлы (но не новые, новые нужно добавлять отдельно).
Флаг -m "Сообщение коммита"(--message="Сообщение коммита") позволяет не открывать редактор, а указывать сообщение прямо в командной строке.

$ git commit --amend -m "Новое название коммита"
$ git push --force
Эти 2 команды выполняем, чтобы переименовать commit и запушить это изменение.
```````````````````````````````````````````````

История. Решение проблем. Справка

$ git log
показывает историю коммитов: автора, дату, текст комита и идентификатор

$ q
выход обратно в терминал

$ git show 0325f
Пишем git show и первые 7 символов идентификатора комита и видим какие изменения произошли

$ git rm [абсолют. путь к файлу]
Удаляет конкретный файл из рабочей директории и индексирует его удаление

$ git rm --cached [абсолют. путь к файлу]
Убирает конкретный файл из контроля версий, но физически оставляет его на своём месте

$ git rm --cached -r [абсолют. путь к папке]
удаляет из отслеживания папку

$ git commit --amend -m 'Новый комит'
Переписать последний комит

$ git revert <идентификатор комита>
коммит с новыми изменениями, отменяющими предыдущие. Это нужно для изменения уже запушенных коммитов.
Не меняет истории - безопасный способ откатить изменения.

$ git help
справка

```````````````````````````````````````````````

.gitignore

https://github.com/github/gitignore
здесь все комиты для различных языков программирования
файл .gitignore нужно добавлять до первого комита

|||||||||||||| Пример файла с презентации Нетологии ||||||||||||||||
# будут игнорироваться все файлы и каталоги Thumbs.db
# вне зависимости от того, в каком каталоге они находятся
Thumbs.db

# будет игнорироваться каталог tmp
# вне зависимости от того, в каком каталоге он находится
# слэш в конце указывает, что это каталог
tmp/ 

# будет игнорироваться относительно файла .gitingore
# чаще всего относительно всего проекта
/tmp/

# будут игнорироваться все файлы и каталоги с расширением .txt
# вне зависимости от того, в каком каталоге они находятся
*.txt



|||||||||||||| Пример файла с https://support.rdb24.com/hc/ru/articles/115000463769-
%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D
0%BA%D1%81%D0%B8%D1%81%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-gitignore ||||||||||||||||
# Игнор-лист файлов проекта
# Игнорировать ВСЕ файлы и директории, включая поддиректории и файлы в них
*

# ---- ФАЙЛЫ ----
# Игнорирование по типу файла, будут игнорироваться в АБСОЛЮТНО всех директориях
# Например /files/data.zip, /server.log, /uploads/users/data/info.xls
*.zip
*.log
*.pdf
*.xls
# Игнорирование файла во ВСЕХ директориях
# Например /params/db/config.php, /config.php
config.php
# Игнорирование конкретного файла ТОЛЬКО в корне проекта
# (корнём считается расположение файла .gitignore)
# Например НЕ БУДЕТ проигнорирован файл /db/config.php
/config.php
# Игнорирование конкретного файла ТОЛЬКО в указанной директории
# Например НЕ БУДЕТ проигнорирован файл /prod/params/config.php
/params/config.php

# ---- ДИРЕКТОРИИ ----
# Игнорирование всех файлов и папок ТОЛЬКО в конкретной директории(включая поддиректории и файлы в них)
# Например /images/user.jpg, /images/company/logo.png
# НЕ БУДУТ проигнорированы файлы и папки /prod/images/user.jpg
/images/*
# Игнорирование всех файлов и папок в ЛЮБЫХ директориях с указанным именем
# Например /images/user.jpg, /core/images/user.jpg
images/*
# Игнорирование ВСЕХ html-файлов в ОДНОЙ КОНКРЕТНОЙ директории(НЕ ВКЛЮЧАЯ поддиректории)
# Например /private/index.html
# НЕ БУДУТ проигнорированы файлы в /private/ivan/index.html
/private/*.html
# Игнорирование ВСЕХ html-файлов в КОНКРЕТНОЙ директории ВКЛЮЧАЯ поддиректории
# Например /private/info.html, /private/users/ivan/info.html
/private/**/*.html

# ---- РАЗНОЕ ----
# Исключение из игнорирования
# Игнорирование ВСЕХ файлов и папок внутри директории /secret,
# за исключением файла /secret/free.txt, он не будет проигнорирован
/secret/*
!/secret/free.txt
# Игнорирование файла с именем, содержащим спецсимволы
# Например !readme!.txt
\!readme!.txt
# Игнорирование всех JPG и JPEG файлов внутри директорий,
# которые начинаются на "h" и МОГУТ содержать ещё один символ после
# Например /images/h4/user.jpg, /images/h/company.jpeg
/images/h?/*.jp?g

```````````````````````````````````````````````

Редакторы кода. github

$ git clone <урл репо>
добавляем удаленный репо

заходим папку, в которой гит баш делали и 
$ cd <'абсолют. путь папки'>
переходим в папку

чтобы закачать себе любой общедоступный репо, нужно на гитхабе нажать на зеленый 'Code' и далее там скопировать ссылку и набрать в гит баше
$ git clone <ссылка>

$ git remote -v
показывает, какие удаленные репо привязаны к нашему локальному

$ git push -u origin master
это первичный посыл данных на гитхаб
флаг -u означает, что на удаленном репо мы создаем одноименную ветку. Поэтому команда git push -u origin master используется только для первичной отправки данных. Во всех остальных случаях просто git push

$ git push
второй и последующий посыл данных на гитхаб

$ git remote add origin <урл репо>
привязываем удаленный репо к локальному

```````````````````````````````````````````````
MARCDOWN

Посмотреть все возможности оформления, которые предлагает сервис GitHub можно по ссылке: https://guides.github.com/features/mastering-markdown/

README.md - такой файл принято использовать на гл страничке проекта на гитхабе

# Заголовок - так пишется заголовок 1-го уровня

## Заголовок - так пишется заголовок 2-го уровня

### Заголовок - так пишется заголовок 3-го уровня

**Жирный текст**

*Наклонный текст*

~~Перечеркнутый текст~~

  * Элемент списка
  * Элемент списка
    * Вложенный элемент списка
    * Вложенный элемент списка

  1.Элемент упорядоченного списка
  1.Элемент упорядоченного списка
    1. Вложенный элемент списка
    1. Вложенный элемент списка

ГИПЕРССЫЛКИ
Гиперссылки оформляются в формате
[Текст ссылки](url-адрес)
[Текст ссылки](http://localhost)

ИЗОБРАЖЕНИЯ
Изображения оформляются также, как и гиперссылки,
но перед [] ставится !,т.е.
![логотип](url-изображения)
![Bootstrap logo](https://i.imgur.com/qhtywl2.png)

КОД
Есть два варианта оформления  кода:
— Inline: код заключается в backtick'и: `строка кода`
— Block: код с подсветкой синтаксиса:
```javascript (тут прописываем назв. языка)
console.log("");
```
или другой пример:
```html
<linkrel="stylesheet"
        href="https://stackpath.bootstrapcdn.com/bootstrap/43/css/bootstrap.min.css"
        integrity="sha284-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkF0JwJ8ERdknLPMO"
        crossorigin="anonymous">
```

```````````````````````````````````````````````
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
```````````````````````````````````````````````
lesson_2: Work history and branches

branches

$ git branch <название ветки>
создаем новую ветку

$ git branch
просматриваем, какие ветки у нас есть

$ git branch -vv
просматриваем, какая локальная ветка относится к какой удаленной

$ git checkout <название ветки>
переключаемся на другую ветку

$ git checkout -b <название новой ветки>
одновременно создаем новую ветку и переключаемся на нее

когда мы делаем git push -u origin 
то гит по умолчанию отправляет на гитхаб изменения с ветки master. Чтобы отправить изменения с какой-либо другой ветки, нам нужно написать
$ git push -u origin <название ветки>

```````````````````````````````````````````````

merge changes

для начала, если мы сейчас не на главной ветке, то переключаемся на нее
$ git checkout master

$ git merge --no -ff <назв. ветки, которую хотим смерджить>
сливаем ветки. Тут благодаря этим флагам уже в ветке master создается комит, который фиксирует изменения, которые произошли при слиянии веток. Тут может выскочить редактор с уже заполненной информацией, ее просто нужно сохранить.

$ git merge --no -ff <назв.ветки,кот.хот.смерд.> -m 'My_commit'
есть альтернатива, чтобы не связываться с редактором, чтобы
сразу прописать комит

$ git log --oneline --graph
гит покажет graph комитов (диаграмму). Покажет, на каких комитах произошло слияние

$ git log --oneline --graph --all
более полная диаграмма

$ git log --oneline
показывает только идентификатор комита и текст комита

```````````````````````````````````````````````

conflicts

когда происходит конфликт при слиянии веток, то заходим с ВСКод. Он на данном этапе автоматически показывает, где произошел конфликт. Делает он это с помощью спецсимволов, так как ВСКод уже интегрирован с гит. Далее руками убираем все строки, на которых есть спец символы отображения конфликта. И в итоге у нас остаются изменения и с одной ветки, и с другой. Решение конфликтов затем обязательно нужно закомитить.


```````````````````````````````````````````````

deleting branches, tags

$ git branch -d <имя_ветки>
Удаление локальной ветки.
При этом удаляемая ветка не должна быть текущей

$ git push --delete origin <название ветки>
Удаление удаленной ветки с гихаба.
При этом удаляемая ветка не должна быть текущей

$ git tag –a <название тега> –m "сообщение тега"
теги нам заменяют длинные и неудобные идентификаторы комитов
тут мы внутри комита создаем бирку

$ git tag
посмотреть список существующих тегов

$ git show <название тега>
теперь в команде git show мы можем использовать не длинный идентификатор комита, а название тега

$ git push --tags
по умолчанию, при git push теги на гитхаб не отправляются. Чтобы они отправились есть специальный флаг --tags, тут это нужно отдельно отправлять: git push --tags

$ git tag -d <название тега>
удаление локального тега, если еще не отправили тег на гитхаб

$ git push --delete origin <название тега>
$ git tag -d <название тега>
удаление тега на гитхабе. Сначала удаляем тег на гитхабе, а потом локально

```````````````````````````````````````````````

work with history

$ git log -p -- 'абсолют. путь к файлу'
подробный просмотр изменений с файлом

$ git log --grep 'Ini'
так мы находим историю по первым буквам названия комита

$ git log -S 'наш кусок кода' -p
поиск по конкретному куску кода

$ git log --all
поиск по всем веткам сразу. Нужен, так как по умолчанию команда git log ищет только в ветке master

$ git blame -- 'абсолют. путь к файлу'
просмотр авторов изменений

```````````````````````````````````````````````

device branches and HEAD

HEAD указывает на состояние файла (определенное состояние при определенном комите или ветке). Мы можем сдвигать
указатель HEAD на то, что нам нужно с помощью
$ git checkout <идентификатор комита>
тут с помощью git checkout мы можем переключиться не только на каку-то ветку, но и на определенный комит. И
состояние файлов в нашей рабочей директории будет соответствовать тому комиту, на который указывает HEAD.
Когда мы вручную передвигаем HEAD, гит нам говорит, что мы находимся в состоянии 'detached HEAD' (то состояние,
когда наш HEAD не указывает ни на одну ветку) и советует нам потом, после всех изменений создать ветку и залить
туда все комиты, которые мы сделаем.

Теперь подробнее про --no -ff. 
В Git реализован механизм, который называется  fast-forward. Что он делает: если он видит при слиянии изменений,
что самым простым сценарием является просто переместить указатель на ветку на определённый коммит и не делать merge
commit,то он так и поступает. В большинстве случаев это не желательное поведение, поэтому мы отключаем этот механизм
с помощью флага --no -ff.

```````````````````````````````````````````````

reset

git reset Позволяет нам передвигать указать, тем самым эмулируя «отмену» коммитов (сами коммиты по
факту не отменяются, мы просто перемещаем указатель). На самом деле отменить коммиты нельзя, можно лишь сделать новые.
git reset HEAD~1 # удаляет комиты после указанного. Меняет историю - небезопасный способ откатить изменения.
Можно использовать для локальных комитов.

Режимы:
$ git reset <mode> <commit-id>
где <mode> это:
 --hard
передвигаем указатель на определённый коммит, не сохраняя никаких изменений
 --soft
передвигаем указатель на определённый коммит, при этом предыдущие изменения сохраняются в рабочем каталоге и index'е
 --mixed (по умолчанию, можно не указывать).
передвигаем указатель на определённый коммит, при этом предыдущие изменения сохраняются в рабочем каталоге, но не в index'е

Вместо того, чтобы каждый раз указывать id-коммита, мы можем воспользоваться специальным синтаксисом:
$ git reset <mode> HEAD~<num>
Это будет значить, что мы хотим отойти от HEAD на n-шагов.

$ git reset --hard HEAD^
удалить последний локальный незапушенный коммит
$ git reset --hard HEAD~3
удалить последние 3 локальных незапушенных коммита


```````````````````````````````````````````````
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||
```````````````````````````````````````````````
lesson_3: teamwork

remote branches

$ git push --all
отправить на гитхаб изменения со всех веток

При клонировании репозитория с удалённого сервера, Git автоматически создаёт удалённую ветку
origin/master и локальную master. Для всех остальных удалённых веток локальные ветки не создаются,
их нужно создавать с помощью команды:
$ git branch <local-branch> <origin/remote-branch>

Также можно создать локальную ветку с именем, соответствующем удалённой, а также сразу переключиться на
нее, с помощью специальной сокращённой команды:
$ git checkout --track <remote-branch>

$ git fetch <origin>
забирает изменения с удалённого сервера (если они там есть) и сдвигает указатели удалённой
ветки на нужную позицию. fetch работает с тем branch'ем, в котором вы сейчас работаете.

$ git pull позволяет выполнить двухшаговый процесс (fetch+ merge) за один шаг: т.е.вы выкачиваете изменения
нужной ветки и и сразу переходите в режим слияния.

$ git pull --rebase
Позволяет вытягивать изменения из удаленного репозитория, и те изменения, которые мы сделали в локальном
репозитории, ставить поверх вытянутых изменений

```````````````````````````````````````````````
issues, pull requests, GitHub Pages - см. презентацию

```````````````````````````````````````````````
```````````````````````````````````````````````
```````````````````````````````````````````````
```````````````````````````````````````````````
```````````````````````````````````````````````
НАГУГЛЕННЫЕ ФИШКИ ГИТА:

Как удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами,
вы можете захотеть оставить файл на жестком диске, и убрать его из-под бдительного ока Git'а:
$ git rm --cached 'my_file.txt' (название прописываем как в репозитории и в кавычках'
$ git commit 'my regular commit'
$ git push


Как объединить коммиты, которые уже запушены:
https://pingvinus.ru/git/1591
https://htmlacademy.ru/blog/boost/tools/how-to-squash-commits-and-why-it-is-needed
1) $ git rebase -i HEAD~2    тут под цифрой мы можем выбирать кол-во последних коммитов для объединений
2) оставляем "pick" под тем комитом, К КОТОРОМУ мы хотим приклеить другой коммит, и изменяем pick на "s" для коммита, КОТОРЫЙ прикркпляем
3) нажимаем: control+O -> Enter -> control+X
4) редактор открывается еще раз, нажимаем: control+O -> Enter -> control+X
5) $ git pull
6) редактор открывается еще раз, нажимаем: control+O -> Enter -> control+X
7) $ git push